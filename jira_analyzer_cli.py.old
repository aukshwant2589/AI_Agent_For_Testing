#!/usr/bin/env python3
"""
JIRA Ticket Analyzer - Command line interface for analyzing JIRA tickets
"""

import argparse
import sys
import os
import json
import logging
from pathlib import Path
from typing import Dict, List, Optional
from dotenv import load_dotenv

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))

from src.core import TestCaseGenerator, JIRAClient
from src.core.test_case_generator import PlaywrightTestGenerator

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv(verbose=True)

# Display environment variables (without sensitive values)
logger.info("Loading JIRA credentials:")
logger.info(f"JIRA_EMAIL: {'*' * 20}")
logger.info(f"JIRA_API_TOKEN: {'*' * 10}")
logger.info(f"JIRA_SERVER: {os.getenv('JIRA_SERVER', 'https://auxworx.atlassian.net')}")

class JiraAnalyzer:
    def __init__(self, output_dir: Path):
        """Initialize JiraAnalyzer.
        
        Args:
            output_dir: Path to output directory
        """
        self.output_dir = Path(output_dir)
        self.generator = TestCaseGenerator()
        self.jira_client = JIRAClient()
        
    def get_jira_issue(self, ticket_id: str) -> Dict:
        """Get JIRA issue data.
        
        Args:
            ticket_id: JIRA ticket ID
            
        Returns:
            Dictionary containing issue data
        """
        try:
            issue_data = self.jira_client.get_issue(ticket_id)
            
            if not issue_data:
                raise ValueError(f"Could not fetch details for ticket {ticket_id}")
                
            return {
                'key': ticket_id,
                'summary': issue_data.get('summary', ''),
                'description': issue_data.get('description', ''),
                'acceptance_criteria': issue_data.get('acceptance_criteria', '')
            }
            
        except Exception as e:
            logger.error(f"Error fetching JIRA issue: {str(e)}", exc_info=True)
            raise
            
    def setup_output_directory(self, ticket_id: str) -> Dict[str, str]:
        """Setup output directory structure for a ticket.
        
        Args:
            ticket_id: JIRA ticket ID
            
        Returns:
            Dictionary of created directory paths
        """
        dirs = {
            'base': self.output_dir / ticket_id,
            'tests': self.output_dir / ticket_id / 'tests',
            'playwright': self.output_dir / ticket_id / 'playwright',
            'reports': self.output_dir / ticket_id / 'reports'
        }
        
        for dir_path in dirs.values():
            dir_path.mkdir(parents=True, exist_ok=True)
            
        return {k: str(v) for k, v in dirs.items()}
        
    def process_ticket(self, ticket_id: str, options: Dict) -> Optional[Dict]:
        """Process a single JIRA ticket.
        
        Args:
            ticket_id: JIRA ticket ID
            options: Processing options
            
        Returns:
            Generated test cases if successful
        """
        try:
            # Setup directories
            output_dirs = self.setup_output_directory(ticket_id)
            
            # Get issue data
            issue_data = self.get_jira_issue(ticket_id)
            
            if not issue_data:
                raise ValueError(f"Could not fetch details for ticket {ticket_id}")
                
            # Generate test cases
            test_cases = self.generator.generate_test_cases(
                issue_data,
                output_dirs['base'],
                learning_enabled=options.get('learning', True)
            )
            
            if test_cases:
                playwright_gen = PlaywrightTestGenerator(output_dirs['playwright'])
                playwright_gen.generate_playwright_tests(test_cases)
                logger.info("Generated Playwright tests successfully")
                
            logger.info(f"Test scripts generated successfully for {ticket_id}")
            return test_cases
            
        except Exception as e:
            logger.error(f"Error processing ticket {ticket_id}: {str(e)}")
            raise
            
    def process_batch(self, batch_file: str) -> None:
        """Process multiple tickets from a file.
        
        Args:
            batch_file: Path to file containing ticket IDs
        """
        try:
            with open(batch_file) as f:
                tickets = [line.strip() for line in f if line.strip()]
                
            for ticket in tickets:
                logger.info(f"Processing ticket: {ticket}")
                self.process_ticket(ticket, {'learning': True})
                
        except Exception as e:
            logger.error(f"Error processing batch file: {str(e)}")
            sys.exit(1)
            
    def run(self, args: argparse.Namespace) -> None:
        """Run the CLI with provided arguments.
        
        Args:
            args: Parsed command line arguments
        """
        try:
            if args.batch_file:
                self.process_batch(args.batch_file)
            else:
                ticket_id = args.ticket or self._extract_ticket_id(args.url)
                if not ticket_id:
                    logger.error("No ticket ID provided")
                    sys.exit(1)
                    
                options = {
                    'learning': not args.no_learning,
                    'format': args.format
                }
                
                self.process_ticket(ticket_id, options)
                
        except Exception as e:
            logger.error(f"Error: {str(e)}")
            sys.exit(1)
            
    def _extract_ticket_id(self, url: Optional[str]) -> Optional[str]:
        """Extract ticket ID from JIRA URL.
        
        Args:
            url: JIRA ticket URL
            
        Returns:
            Extracted ticket ID or None
        """
        if not url:
            return None
            
        try:
            return url.split('/')[-1]
        except:
            return None

def main():
    """Main entry point for the CLI."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Generate test cases from JIRA tickets")
    parser.add_argument("--ticket", help="JIRA ticket ID")
    parser.add_argument("--url", help="JIRA ticket URL")
    parser.add_argument("--output-dir", default="generated_tests", help="Output directory")
    parser.add_argument("--format", default="all", choices=["all", "feature", "pytest"], help="Output format")
    parser.add_argument("--batch-file", help="Path to file containing list of ticket IDs")
    parser.add_argument("--no-learning", action="store_true", help="Disable learning mode")
    
    args = parser.parse_args()
    
    try:
        # Create analyzer instance
        analyzer = JiraAnalyzer(Path(args.output_dir))
        
        # Run the analyzer
        analyzer.run(args)
    except KeyboardInterrupt:
        logger.info("Process interrupted by user")
        sys.exit(0)

if __name__ == "__main__":
    main()
"""
JIRA Ticket Analyzer - Command line interface for analyzing JIRA tickets
"""

import argparse
import sys
import os
import json
import logging
from pathlib import Path
from typing import Dict, List, Optional
from dotenv import load_dotenv

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))

from src.core import TestCaseGenerator, JIRAClient
from src.core.test_case_generator import PlaywrightTestGenerator

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv(verbose=True)

# Display environment variables (without sensitive values)
logger.info("Loading JIRA credentials:")
logger.info(f"JIRA_EMAIL: {'*' * 20}")
logger.info(f"JIRA_API_TOKEN: {'*' * 10}")
logger.info(f"JIRA_SERVER: {os.getenv('JIRA_SERVER', 'https://auxworx.atlassian.net')}")

class JiraAnalyzer:
    """A class to analyze JIRA tickets and generate test cases."""
    
    def __init__(self, output_dir: Path):
        """Initialize JiraAnalyzer.
        
        Args:
            output_dir: Path to output directory
        """
        self.output_dir = Path(output_dir)
        self.generator = TestCaseGenerator()
        self.jira_client = JIRAClient()
        
    def get_jira_issue(self, ticket_id: str) -> Dict:
        """Get JIRA issue data.
        
        Args:
            ticket_id: JIRA ticket ID
            
        Returns:
            Dictionary containing issue data
        """
        try:
            issue_data = self.jira_client.get_issue(ticket_id)
            
            if not issue_data:
                raise ValueError(f"Could not fetch details for ticket {ticket_id}")
                
            return {
                'key': ticket_id,
                'summary': issue_data.get('summary', ''),
                'description': issue_data.get('description', ''),
                'acceptance_criteria': issue_data.get('acceptance_criteria', '')
            }
            
        except Exception as e:
            logger.error(f"Error fetching JIRA issue: {str(e)}", exc_info=True)
            raise
            
    def setup_output_directory(self, ticket_id: str) -> Dict[str, str]:
        """Setup output directory structure for a ticket.
        
        Args:
            ticket_id: JIRA ticket ID
            
        Returns:
            Dictionary of created directory paths
        """
        dirs = {
            'base': self.output_dir / ticket_id,
            'tests': self.output_dir / ticket_id / 'tests',
            'playwright': self.output_dir / ticket_id / 'playwright',
            'reports': self.output_dir / ticket_id / 'reports'
        }
        
        for dir_path in dirs.values():
            dir_path.mkdir(parents=True, exist_ok=True)
            
        return {k: str(v) for k, v in dirs.items()}
        
    def process_ticket(self, ticket_id: str, options: Dict) -> None:
        """Process a single JIRA ticket.
        
        Args:
            ticket_id: JIRA ticket ID
            options: Processing options
        """
        try:
            # Setup directories
            output_dirs = self.setup_output_directory(ticket_id)
            
            # Get issue data
            issue_data = self.get_jira_issue(ticket_id)
            
            if not issue_data:
                raise ValueError(f"Could not fetch details for ticket {ticket_id}")
                
            # Generate test cases
            test_cases = self.generator.generate_test_cases(
                issue_data,
                output_dirs['base'],
                learning_enabled=options.get('learning', True)
            )
            
            if test_cases:
                playwright_gen = PlaywrightTestGenerator(output_dirs['playwright'])
                playwright_gen.generate_playwright_tests(test_cases)
                logger.info("Generated Playwright tests successfully")
                
            logger.info(f"Test scripts generated successfully for {ticket_id}")
            return test_cases
            
        except Exception as e:
            logger.error(f"Error processing ticket {ticket_id}: {str(e)}")
            raise
            
    def process_batch(self, batch_file: str) -> None:
        """Process multiple tickets from a file.
        
        Args:
            batch_file: Path to file containing ticket IDs
        """
        try:
            with open(batch_file) as f:
                tickets = [line.strip() for line in f if line.strip()]
                
            for ticket in tickets:
                logger.info(f"Processing ticket: {ticket}")
                self.process_ticket(ticket, {'learning': True})
                
        except Exception as e:
            logger.error(f"Error processing batch file: {str(e)}")
            sys.exit(1)
            
    def run(self, args: argparse.Namespace) -> None:
        """Run the CLI with provided arguments.
        
        Args:
            args: Parsed command line arguments
        """
        try:
            if args.batch_file:
                self.process_batch(args.batch_file)
            else:
                ticket_id = args.ticket or self._extract_ticket_id(args.url)
                if not ticket_id:
                    logger.error("No ticket ID provided")
                    sys.exit(1)
                    
                options = {
                    'learning': not args.no_learning,
                    'format': args.format
                }
                
                self.process_ticket(ticket_id, options)
                
        except Exception as e:
            logger.error(f"Error: {str(e)}")
            sys.exit(1)
            
    def _extract_ticket_id(self, url: Optional[str]) -> Optional[str]:
        """Extract ticket ID from JIRA URL.
        
        Args:
            url: JIRA ticket URL
            
        Returns:
            Extracted ticket ID or None
        """
        if not url:
            return None
            
        try:
            return url.split('/')[-1]
        except:
            return None

def main():
    """Main entry point for the CLI."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Generate test cases from JIRA tickets")
    parser.add_argument("--ticket", help="JIRA ticket ID")
    parser.add_argument("--url", help="JIRA ticket URL")
    parser.add_argument("--output-dir", default="generated_tests", help="Output directory")
    parser.add_argument("--format", default="all", choices=["all", "feature", "pytest"], help="Output format")
    parser.add_argument("--batch-file", help="Path to file containing list of ticket IDs")
    parser.add_argument("--no-learning", action="store_true", help="Disable learning mode")
    
    args = parser.parse_args()
    
    # Create analyzer instance
    analyzer = JiraAnalyzer(Path(args.output_dir))
    
    try:
        # Run the analyzer
        analyzer.run(args)
    except KeyboardInterrupt:
        logger.info("Process interrupted by user")
        sys.exit(0)
        
if __name__ == "__main__":
    main()
        analyzer.run(args)
    except KeyboardInterrupt:
        logger.info("Process interrupted by user")
        sys.exit(0)
        
if __name__ == "__main__":
    main()

class JiraAnalyzer:
    """A class to analyze JIRA tickets and generate test cases."""
    
    def __init__(self, output_dir: Path):
        """Initialize JiraAnalyzer.
        
        Args:
            output_dir: Path to output directory
        """
        self.output_dir = Path(output_dir)
        self.generator = TestCaseGenerator()
        self.jira_client = JIRAClient()
        
    def get_jira_issue(self, ticket_id: str) -> Dict:
        """Get JIRA issue data.
        
        Args:
            ticket_id: JIRA ticket ID
            
        Returns:
            Dictionary containing issue data
        """
        try:
            issue_data = self.jira_client.get_issue(ticket_id)
            
            if not issue_data:
                raise ValueError(f"Could not fetch details for ticket {ticket_id}")
                
            return {
                'key': ticket_id,
                'summary': issue_data.get('summary', ''),
                'description': issue_data.get('description', ''),
                'acceptance_criteria': issue_data.get('acceptance_criteria', '')
            }
            
        except Exception as e:
            logger.error(f"Error fetching JIRA issue: {str(e)}", exc_info=True)
            raise
        try:
            issue_data = self.jira_client.get_issue(ticket_id)
            
            if not issue_data:
                raise ValueError(f"Could not fetch details for ticket {ticket_id}")
                
            return {
                'key': ticket_id,
                'summary': issue_data.get('summary', ''),
                'description': issue_data.get('description', ''),
                'acceptance_criteria': issue_data.get('acceptance_criteria', '')
            }
            
        except Exception as e:
            logger.error(f"Error fetching JIRA issue: {str(e)}", exc_info=True)
            raise
            
    def process_ticket(self, ticket_id: str, options: Dict) -> None:
        """Process a single JIRA ticket.
        
        Args:
            ticket_id: JIRA ticket ID
            options: Processing options
        """
        try:
            # Setup directories
            output_dirs = self.setup_output_directory(ticket_id)
            
            # Get issue data
            issue_data = self.get_jira_issue(ticket_id)
            
            if not issue_data:
                raise ValueError(f"Could not fetch details for ticket {ticket_id}")
                
            # Generate test cases
            test_cases = self.generator.generate_test_cases(
                issue_data,
                output_dirs['base'],
                learning_enabled=options.get('learning', True)
            )
            
            if test_cases:
                playwright_gen = PlaywrightTestGenerator(output_dirs['playwright'])
                playwright_gen.generate_playwright_tests(test_cases)
                logger.info("Generated Playwright tests successfully")
                
            logger.info(f"Test scripts generated successfully for {ticket_id}")
            return test_cases
            
        except Exception as e:
            logger.error(f"Error processing ticket {ticket_id}: {str(e)}")
            raise
            
    def process_batch(self, batch_file: str) -> None:
        """Process multiple tickets from a file.
        
        Args:
            batch_file: Path to file containing ticket IDs
        """
        try:
            with open(batch_file) as f:
                tickets = [line.strip() for line in f if line.strip()]
                
            for ticket in tickets:
                logger.info(f"Processing ticket: {ticket}")
                self.process_ticket(ticket, {'learning': True})
                
        except Exception as e:
            logger.error(f"Error processing batch file: {str(e)}")
            sys.exit(1)
            
    def run(self, args: argparse.Namespace) -> None:
        """Run the CLI with provided arguments.
        
        Args:
            args: Parsed command line arguments
        """
        try:
            if args.batch_file:
                self.process_batch(args.batch_file)
            else:
                ticket_id = args.ticket or self._extract_ticket_id(args.url)
                if not ticket_id:
                    logger.error("No ticket ID provided")
                    sys.exit(1)
                    
                options = {
                    'learning': not args.no_learning,
                    'format': args.format
                }
                
                self.process_ticket(ticket_id, options)
                
        except Exception as e:
            logger.error(f"Error: {str(e)}")
            sys.exit(1)
            
    def _extract_ticket_id(self, url: Optional[str]) -> Optional[str]:
        """Extract ticket ID from JIRA URL.
        
        Args:
            url: JIRA ticket URL
            
        Returns:
            Extracted ticket ID or None
        """
        if not url:
            return None
            
        try:
            return url.split('/')[-1]
        except:
            return None
            logger.error(f"Error fetching JIRA issue: {str(e)}", exc_info=True)
            raise
            
    def setup_output_directory(self, ticket_id: str) -> Dict[str, str]:
        """Setup output directory structure for a ticket.
        
        Args:
            ticket_id: JIRA ticket ID
            
        Returns:
            Dictionary of created directory paths
        """
        dirs = {
            'base': self.output_dir / ticket_id,
            'tests': self.output_dir / ticket_id / 'tests',
            'playwright': self.output_dir / ticket_id / 'playwright',
            'reports': self.output_dir / ticket_id / 'reports'
        }
        
        for dir_path in dirs.values():
            dir_path.mkdir(parents=True, exist_ok=True)
            
        return {k: str(v) for k, v in dirs.items()}
        
    def process_ticket(self, ticket_id: str, options: Dict) -> None:
        """Process a single JIRA ticket.
        
        Args:
            ticket_id: JIRA ticket ID
            options: Processing options
        """
        try:
            # Setup directories
            output_dirs = self.setup_output_directory(ticket_id)
            
            # Get issue data
            issue_data = self.get_jira_issue(ticket_id)
            
            if not issue_data:
                raise ValueError(f"Could not fetch details for ticket {ticket_id}")
                
            # Generate test cases
            test_cases = self.generator.generate_test_cases(
                issue_data,
                output_dirs['base'],
                learning_enabled=options.get('learning', True)
            )
            
            logger.info(f"Test scripts generated successfully for {ticket_id}")
            return test_cases
            
        except Exception as e:
            logger.error(f"Error processing ticket {ticket_id}: {str(e)}")
            raise
        dirs = {
            'base': self.output_dir / ticket_id,
            'tests': self.output_dir / ticket_id / 'tests',
            'playwright': self.output_dir / ticket_id / 'playwright',
            'reports': self.output_dir / ticket_id / 'reports'
        }
        
        for dir_path in dirs.values():
            dir_path.mkdir(parents=True, exist_ok=True)
            
        return {k: str(v) for k, v in dirs.items()}
        
    def process_ticket(self, ticket_id: str, options: Dict) -> None:
        """Process a single JIRA ticket.
        
        Args:
            ticket_id: JIRA ticket ID
            options: Processing options
        """
        try:
            # Setup directories
            output_dirs = self.setup_output_directory(ticket_id)
            
            # Get ticket data
            jira_client = JIRAClient(self.config.jira_config)
            issue_data = jira_client.get_issue(ticket_id)
            
            # Generate test cases
            test_cases = self.generator.generate_test_cases(
                issue_data,
                output_dirs['base'],
                learning_enabled=options.get('learning', True)
            )
            
            logger.info(f"Test scripts generated successfully for {ticket_id}")
            return test_cases
            
        except Exception as e:
            logger.error(f"Error processing ticket {ticket_id}: {str(e)}")
            raise
            
    def process_batch(self, batch_file: str) -> None:
        """Process multiple tickets from a file.
        
        Args:
            batch_file: Path to file containing ticket IDs
        """
        try:
            with open(batch_file) as f:
                tickets = [line.strip() for line in f if line.strip()]
                
            for ticket in tickets:
                logger.info(f"Processing ticket: {ticket}")
                self.process_ticket(ticket, {'learning': True})
                
        except Exception as e:
            logger.error(f"Error processing batch file: {str(e)}")
            sys.exit(1)
            
    def run(self, args: argparse.Namespace) -> None:
        """Run the CLI with provided arguments.
        
        Args:
            args: Parsed command line arguments
        """
        try:
            if args.batch_file:
                self.process_batch(args.batch_file)
            else:
                ticket_id = args.ticket or self._extract_ticket_id(args.url)
                if not ticket_id:
                    logger.error("No ticket ID provided")
                    sys.exit(1)
                    
                options = {
                    'learning': not args.no_learning,
                    'format': args.format
                }
                
                self.process_ticket(ticket_id, options)
                
        except Exception as e:
            logger.error(f"Error: {str(e)}")
            sys.exit(1)
            
    def _extract_ticket_id(self, url: Optional[str]) -> Optional[str]:
        """Extract ticket ID from JIRA URL.
        
        Args:
            url: JIRA ticket URL
            
        Returns:
            Extracted ticket ID or None
        """
        if not url:
            return None
            
        # Extract ticket ID from URL
        try:
            return url.split('/')[-1]
        except:
            return None

def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Generate test cases from JIRA tickets")
    parser.add_argument("--ticket", help="JIRA ticket ID")
    parser.add_argument("--url", help="JIRA ticket URL")
    parser.add_argument("--output-dir", default="generated_tests", help="Output directory")
    parser.add_argument("--format", default="all", choices=["all", "feature", "pytest"], help="Output format")
    parser.add_argument("--batch-file", help="Path to file containing list of ticket IDs")
    parser.add_argument("--no-learning", action="store_true", help="Disable learning mode")
    
    args = parser.parse_args()
    
    # Create analyzer instance
    analyzer = JiraAnalyzer(Path(args.output_dir))
    
    try:
        # Run the analyzer
        analyzer.run(args)
    except KeyboardInterrupt:
        logger.info("Process interrupted by user")
        sys.exit(0)
        
if __name__ == "__main__":
    main()
        
        # Get issue details
        issue_data = jira.get_issue_details(ticket_id)
        if not issue_data:
            raise ValueError(f"Could not fetch details for ticket {ticket_id}")
            
        # Extract test requirements
        test_requirements = jira.extract_test_requirements(issue_data)
        
        return {
            **issue_data,
            'test_requirements': test_requirements
        }
        
    except Exception as e:
        logger.error(f"Error fetching JIRA issue: {str(e)}", exc_info=True)
        raise

def generate_test_cases(
    ticket_id: str,
    args,
    output_dirs: Dict[str, str]
) -> List[Dict]:
    """Generate test cases for a ticket"""
    # Get JIRA issue data
    issue_data = get_jira_issue(ticket_id)
    
    # Initialize test case generator
    generator = TestCaseGenerator()
    
    # Generate test scenarios
    test_cases = generator.generate_test_scenarios(
        issue_data=issue_data
    )
    
    # Generate automation if requested
    if args.generate_automation:
        playwright_gen = PlaywrightTestGenerator(output_dirs['playwright'])
        playwright_gen.generate_automation_scripts(test_cases)
        
    # Save test cases
    output_file = os.path.join(output_dirs['tests'], 'test_cases.json')
    with open(output_file, 'w') as f:
        json.dump(test_cases, f, indent=2)
        
    return test_cases

def export_results(
    test_cases: List[Dict],
    export_type: str,
    output_dir: str
) -> None:
    """Export test cases to specified format"""
    if export_type == 'testrail':
        # TODO: Implement TestRail export
        pass
    elif export_type == 'xray':
        # TODO: Implement Xray export
        pass
    elif export_type == 'jira':
        # TODO: Implement JIRA export
        pass
    elif export_type == 'browserstack':
        # TODO: Implement BrowserStack export
        pass

def display_results(
    test_cases: List[Dict],
    output_format: str,
    output_dir: str
) -> None:
    """Display results in specified format"""
    if output_format == 'json':
        print(json.dumps(test_cases, indent=2))
    elif output_format == 'text':
        print(f"# Generated by Ultimate Test Automation Coordinator\n")
        print(f"Feature: Test cases for JIRA ticket\n")
        
        # Group test cases by category
        categorized = {}
        for tc in test_cases:
            category = tc.get('category', 'functional').capitalize()
            if category not in categorized:
                categorized[category] = []
            categorized[category].append(tc)
            
        # Display test cases by category
        for category, cases in categorized.items():
            print(f"# {category} Tests")
            print("=" * 80 + "\n")
            
            for tc in cases:
                print(f"Scenario: {tc['name']}")
                print(f"    Description: {tc['description']}")
                print(f"    Category: {category}")
                print(f"    Test Data:")
                
                # Display test data in a readable format
                if tc.get('test_data'):
                    for key, value in tc['test_data'].get('inputs', {}).items():
                        print(f"        Input - {key}: {value}")
                    for key, value in tc['test_data'].get('validation', {}).items():
                        print(f"        Validation - {key}: {value}")
                print()
                
                # Display steps with proper Gherkin formatting
                for step in tc['steps']:
                    if step.startswith('Given'):
                        print(f"    {step}")
                    elif step.startswith('When'):
                        print(f"    {step}")
                    elif step.startswith('Then'):
                        print(f"    {step}")
                    elif step.startswith('And'):
                        print(f"    {step}")
                    else:
                        print(f"    Given {step}")
                
                # Display expected result
                if tc.get('expected_result'):
                    print(f"    Then {tc['expected_result']}")
                print("\n")
    elif output_format == 'html':
        # TODO: Implement HTML report generation
        pass

def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser(description='Analyze JIRA tickets and generate test cases')
    
    # Main arguments group
    main_group = parser.add_argument_group('Main Options')
    main_group.add_argument('--ticket', help='JIRA ticket ID (e.g., KAN-1)')
    main_group.add_argument('--url', help='Full JIRA ticket URL')
    main_group.add_argument('--batch', help='Comma-separated list of ticket IDs for batch processing')
    
    # Generation options
    gen_group = parser.add_argument_group('Generation Options')
    gen_group.add_argument('--generate-automation', action='store_true',
                          help='Generate Playwright automation scripts')
    gen_group.add_argument('--framework', 
                          choices=['pytest', 'unittest', 'behave', 'robot', 'playwright'],
                          default='pytest',
                          help='Test framework format')
    gen_group.add_argument('--template',
                          choices=['default', 'security', 'performance', 'accessibility'],
                          default='default',
                          help='Test case template to use')
                          
    # Output options
    output_group = parser.add_argument_group('Output Options')
    output_group.add_argument('--output', '-o',
                             choices=['json', 'text', 'html'],
                             default='text',
                             help='Output format')
    output_group.add_argument('--output-dir',
                             default='generated_tests',
                             help='Output directory for generated files')
    
    # Export options
    export_group = parser.add_argument_group('Export Options')
    export_group.add_argument('--export',
                             choices=['testrail', 'xray', 'jira', 'browserstack'],
                             help='Export to test management system')
    
    # Advanced options
    adv_group = parser.add_argument_group('Advanced Options')
    adv_group.add_argument('--prioritize', action='store_true',
                          help='Auto-prioritize test cases')
    adv_group.add_argument('--complexity',
                          choices=['low', 'medium', 'high'],
                          default='medium',
                          help='Test case complexity level')
    adv_group.add_argument('--coverage',
                          choices=['basic', 'full', 'comprehensive'],
                          default='full',
                          help='Test coverage level')
    
    args = parser.parse_args()
    
    # Validate arguments
    if not any([args.ticket, args.url, args.batch]):
        parser.error("Must provide either --ticket, --url, or --batch")
        
    try:
        # Process single ticket
        if args.ticket or args.url:
            ticket_id = args.ticket or args.url.split('/')[-1]
            
            # Setup output directories
            output_dirs = setup_output_directory(args.output_dir, ticket_id)
            
            # Generate test cases
            test_cases = generate_test_cases(ticket_id, args, output_dirs)
            
            # Export if requested
            if args.export:
                export_results(test_cases, args.export, output_dirs['reports'])
                
            # Display results
            display_results(test_cases, args.output, output_dirs['reports'])
            
        # Process batch
        elif args.batch:
            ticket_ids = [tid.strip() for tid in args.batch.split(',')]
            
            for ticket_id in ticket_ids:
                print(f"\nProcessing ticket: {ticket_id}")
                output_dirs = setup_output_directory(args.output_dir, ticket_id)
                test_cases = generate_test_cases(ticket_id, args, output_dirs)
                
                if args.export:
                    export_results(test_cases, args.export, output_dirs['reports'])
                    
                display_results(test_cases, args.output, output_dirs['reports'])
                
    except Exception as e:
        print(f"Error: {str(e)}", file=sys.stderr)
        sys.exit(1)

        analyzer = JIRAAIAnalyzer()

        # Handle batch processing
        if args.batch:
            print(f"Processing batch of tickets: {args.batch}")
            print("=" * 60)
            
            ticket_ids = [ticket_id.strip() for ticket_id in args.batch.split(',')]
            results = analyzer.process_batch_tickets(ticket_ids, args.output_dir)
            
            print(f"âœ… Batch processing completed!")
            print(f"ğŸ“Š Total tickets: {results['total_tickets']}")
            print(f"âœ… Successful: {results['successful']}")
            print(f"âŒ Failed: {results['failed']}")
            print(f"ğŸ“ Results saved to: {args.output_dir}/")
            
            return

        # Handle single ticket processing
        print(f"Analyzing JIRA ticket: {args.jira_url}")
        print("=" * 60)

        # Pass additional parameters to the analyzer
        result = analyzer.run(
            args.jira_url, 
            framework=args.framework,
            template=args.template,
            prioritize=args.prioritize,
            export=args.export
        )

        # Parse the JSON response
        data = json.loads(result)
        
        if not data.get('valid', False):
            error_msg = data.get('error', 'Unknown error occurred')
            print(f"âŒ ERROR: {error_msg}")
            print(f"ğŸ“‹ Ticket ID: {data.get('ticket_id', 'N/A')}")
            print(f"ğŸ” Status: Ticket not found or inaccessible")
            sys.exit(1)

        if args.output == 'json':
            print(json.dumps(data, indent=2))
        else:
            # Pretty print for text output
            print(f"âœ… Ticket ID: {data.get('ticket_id', 'N/A')}")
            print(f"ğŸ“‹ Summary: {data.get('ticket_summary', 'N/A')}")
            print(f"ğŸ“Š Test Cases Generated: {data.get('test_cases_generated', 0)}")
            
            if args.prioritize:
                print(f"ğŸ¯ Prioritization: Enabled")
            
            if args.framework != 'pytest':
                print(f"âš™ï¸ Framework: {args.framework}")
            
            if args.template != 'default':
                print(f"ğŸ“ Template: {args.template}")
            
            print(f"\nğŸ“ Description Preview:")
            desc = data.get('ticket_description', '')[:200] + "..." if len(data.get('ticket_description', '')) > 200 else data.get('ticket_description', '')
            print(f"   {desc}")
            
            print(f"\nğŸ“ Generated Files:")
            for file in data.get('generated_files', []):
                print(f"   - {file}")

            print(f"\nğŸ§ª Test Cases:")
            for i, test_case in enumerate(data.get('test_cases', []), 1):
                print(f"\n{i}. ğŸ¯ {test_case.get('name', 'N/A')}")
                print(f"   ğŸ“ Description: {test_case.get('description', 'N/A')}")
                print(f"   âš¡ Priority: {test_case.get('priority', 'N/A')}")
                print(f"   ğŸ·ï¸ Type: {test_case.get('type', 'Functional')}")
                
                if args.prioritize:
                    print(f"   ğŸ“Š Risk Score: {test_case.get('risk_score', 'N/A')}")
                    print(f"   ğŸš€ Execution Priority: {test_case.get('execution_priority', 'N/A')}")
                
                print(f"   ğŸ“‹ Steps:")
                for step_i, step in enumerate(test_case.get('steps', []), 1):
                    print(f"      {step_i}. {step}")
                
                print(f"   âœ… Expected: {test_case.get('expected_result', 'N/A')}")
                print(f"   ğŸ“Š Test Data: {test_case.get('test_data', 'N/A')}")
                print(f"   ğŸ”§ Prerequisites: {test_case.get('prerequisites', 'None')}")

    except ImportError as e:
        print(f"âŒ Import error: {e}")
        print("Make sure the JIRAAIAnalyzer class is available in src/tools/jira_ai_analyzer.py")
        sys.exit(1)
    except json.JSONDecodeError as e:
        print(f"âŒ JSON parsing error: {e}")
        if 'result' in locals():
            print(f"Raw response: {result[:200]}...")
        sys.exit(1)
    except Exception as e:
        print(f"âŒ Unexpected error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()